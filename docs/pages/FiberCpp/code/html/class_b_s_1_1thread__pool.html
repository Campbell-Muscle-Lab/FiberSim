<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FiberSim: BS::thread_pool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FiberSim
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_b_s_1_1thread__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_b_s_1_1thread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BS::thread_pool Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A fast, lightweight, and easy-to-use C++17 thread pool class.  
 <a href="class_b_s_1_1thread__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_b_s__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0705b5edcf3809e4f133272e8070d12" id="r_af0705b5edcf3809e4f133272e8070d12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#af0705b5edcf3809e4f133272e8070d12">thread_pool</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="_b_s__thread__pool_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> <a class="el" href="class_b_s_1_1multi__future.html">thread_count_</a>=0)</td></tr>
<tr class="memdesc:af0705b5edcf3809e4f133272e8070d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool.  <br /></td></tr>
<tr class="separator:af0705b5edcf3809e4f133272e8070d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7cc32367d0d0c020bf103782506998" id="r_a1f7cc32367d0d0c020bf103782506998"><td class="memItemLeft" align="right" valign="top"><a id="a1f7cc32367d0d0c020bf103782506998" name="a1f7cc32367d0d0c020bf103782506998"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~thread_pool</b> ()</td></tr>
<tr class="memdesc:a1f7cc32367d0d0c020bf103782506998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the pool is paused, then any tasks still in the queue will never be executed. <br /></td></tr>
<tr class="separator:a1f7cc32367d0d0c020bf103782506998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5faf242cb0eacbb5c1142a2bd966468" id="r_ab5faf242cb0eacbb5c1142a2bd966468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468">get_tasks_queued</a> () <a class="el" href="class_b_s_1_1multi__future.html">const</a></td></tr>
<tr class="memdesc:ab5faf242cb0eacbb5c1142a2bd966468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently waiting in the queue to be executed by the threads.  <br /></td></tr>
<tr class="separator:ab5faf242cb0eacbb5c1142a2bd966468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b4d97e3a9e40e3228e2ed1f9a717cc" id="r_a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc">get_tasks_running</a> () <a class="el" href="class_b_s_1_1multi__future.html">const</a></td></tr>
<tr class="memdesc:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently being executed by the threads.  <br /></td></tr>
<tr class="separator:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdec64ff8998d66017cc185ae397e064" id="r_afdec64ff8998d66017cc185ae397e064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064">get_tasks_total</a> () <a class="el" href="class_b_s_1_1multi__future.html">const</a></td></tr>
<tr class="memdesc:afdec64ff8998d66017cc185ae397e064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <a class="el" href="class_b_s_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="class_b_s_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="class_b_s_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a>.  <br /></td></tr>
<tr class="separator:afdec64ff8998d66017cc185ae397e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cb80839e30f218818e99af4d1dc64" id="r_afe1cb80839e30f218818e99af4d1dc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_b_s__thread__pool_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#afe1cb80839e30f218818e99af4d1dc64">get_thread_count</a> () <a class="el" href="class_b_s_1_1multi__future.html">const</a></td></tr>
<tr class="memdesc:afe1cb80839e30f218818e99af4d1dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <br /></td></tr>
<tr class="separator:afe1cb80839e30f218818e99af4d1dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7938f7b2b9140c3f6e729b48db79b2" id="r_adc7938f7b2b9140c3f6e729b48db79b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#adc7938f7b2b9140c3f6e729b48db79b2">is_paused</a> () <a class="el" href="class_b_s_1_1multi__future.html">const</a></td></tr>
<tr class="memdesc:adc7938f7b2b9140c3f6e729b48db79b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the pool is currently paused.  <br /></td></tr>
<tr class="separator:adc7938f7b2b9140c3f6e729b48db79b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63b1085ad48295d7f653cbb36a286be" id="r_ab63b1085ad48295d7f653cbb36a286be"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a>  = std::common_type_t&lt;T1, T2&gt;, <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a>  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:ab63b1085ad48295d7f653cbb36a286be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#ab63b1085ad48295d7f653cbb36a286be">parallelize_loop</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a> first_index, <a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a> index_after_last, <a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;<a class="el" href="class_b_s_1_1multi__future.html">loop</a>, <a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a> num_blocks=0)</td></tr>
<tr class="memdesc:ab63b1085ad48295d7f653cbb36a286be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks.  <br /></td></tr>
<tr class="separator:ab63b1085ad48295d7f653cbb36a286be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4e0c7b8e0ac08d9cdad40defd36f30" id="r_a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a>  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a2f4e0c7b8e0ac08d9cdad40defd36f30">parallelize_loop</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a> index_after_last, <a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;<a class="el" href="class_b_s_1_1multi__future.html">loop</a>, <a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a> num_blocks=0)</td></tr>
<tr class="memdesc:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. This overload is used for the special case where the first index is 0.  <br /></td></tr>
<tr class="separator:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb5f1e179eb97f6458d4f77fbb331fd" id="r_aefb5f1e179eb97f6458d4f77fbb331fd"><td class="memItemLeft" align="right" valign="top"><a id="aefb5f1e179eb97f6458d4f77fbb331fd" name="aefb5f1e179eb97f6458d4f77fbb331fd"></a>
<a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pause</b> ()</td></tr>
<tr class="memdesc:aefb5f1e179eb97f6458d4f77fbb331fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause the pool. The workers will temporarily stop retrieving new tasks out of the queue, although any tasks already executed will keep running until they are finished. <br /></td></tr>
<tr class="separator:aefb5f1e179eb97f6458d4f77fbb331fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b0b929324dad46b60a0321477ca352" id="r_ab7b0b929324dad46b60a0321477ca352"><td class="memItemLeft" align="right" valign="top"><a id="ab7b0b929324dad46b60a0321477ca352" name="ab7b0b929324dad46b60a0321477ca352"></a>
<a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>purge</b> ()</td></tr>
<tr class="memdesc:ab7b0b929324dad46b60a0321477ca352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all the tasks waiting in the queue. Tasks that are currently running will not be affected, but any tasks still waiting in the queue will be discarded, and will never be executed by the threads. Please note that there is no way to restore the purged tasks. <br /></td></tr>
<tr class="separator:ab7b0b929324dad46b60a0321477ca352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cec549d4a8729beac50f5eba3ec63f" id="r_ae7cec549d4a8729beac50f5eba3ec63f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a>  = std::common_type_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ae7cec549d4a8729beac50f5eba3ec63f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#ae7cec549d4a8729beac50f5eba3ec63f">push_loop</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a> first_index, <a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a> index_after_last, <a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;<a class="el" href="class_b_s_1_1multi__future.html">loop</a>, <a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a> num_blocks=0)</td></tr>
<tr class="memdesc:ae7cec549d4a8729beac50f5eba3ec63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="class_b_s_1_1thread__pool.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="separator:ae7cec549d4a8729beac50f5eba3ec63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffca1428e1f111220b5f9aed9ff9eac" id="r_a2ffca1428e1f111220b5f9aed9ff9eac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a> &gt; </td></tr>
<tr class="memitem:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a2ffca1428e1f111220b5f9aed9ff9eac">push_loop</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a> index_after_last, <a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;<a class="el" href="class_b_s_1_1multi__future.html">loop</a>, <a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a> num_blocks=0)</td></tr>
<tr class="memdesc:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="class_b_s_1_1thread__pool.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. This overload is used for the special case where the first index is 0.  <br /></td></tr>
<tr class="separator:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a2a6a7a9c844c94c606aaf517b21c" id="r_a016a2a6a7a9c844c94c606aaf517b21c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , typename... A&gt; </td></tr>
<tr class="memitem:a016a2a6a7a9c844c94c606aaf517b21c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a016a2a6a7a9c844c94c606aaf517b21c">push_task</a> (<a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;<a class="el" href="class_b_s_1_1multi__future.html">task</a>, <a class="el" href="class_b_s_1_1multi__future.html">A</a> &amp;&amp;... <a class="el" href="class_b_s_1_1multi__future.html">args</a>)</td></tr>
<tr class="memdesc:a016a2a6a7a9c844c94c606aaf517b21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a function with zero or more arguments, but no return value, into the task queue. Does not return a future, so the user must use <a class="el" href="class_b_s_1_1thread__pool.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the task finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="separator:a016a2a6a7a9c844c94c606aaf517b21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3623b19c51a513fe4612b2157b0314" id="r_a5d3623b19c51a513fe4612b2157b0314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a5d3623b19c51a513fe4612b2157b0314">reset</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="_b_s__thread__pool_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> <a class="el" href="class_b_s_1_1multi__future.html">thread_count_</a>=0)</td></tr>
<tr class="memdesc:a5d3623b19c51a513fe4612b2157b0314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the number of threads in the pool. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="separator:a5d3623b19c51a513fe4612b2157b0314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae308645aebac7a10b04aac0eb3a7c29c" id="r_ae308645aebac7a10b04aac0eb3a7c29c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , typename... A, <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a>  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </td></tr>
<tr class="memitem:ae308645aebac7a10b04aac0eb3a7c29c"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#ae308645aebac7a10b04aac0eb3a7c29c">submit</a> (<a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;<a class="el" href="class_b_s_1_1multi__future.html">task</a>, <a class="el" href="class_b_s_1_1multi__future.html">A</a> &amp;&amp;... <a class="el" href="class_b_s_1_1multi__future.html">args</a>)</td></tr>
<tr class="memdesc:ae308645aebac7a10b04aac0eb3a7c29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with zero or more arguments into the task queue. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an std::future&lt;void&gt; which can be used to wait until the task finishes.  <br /></td></tr>
<tr class="separator:ae308645aebac7a10b04aac0eb3a7c29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57048e0479f878af3ac3a27031a2d6e" id="r_ad57048e0479f878af3ac3a27031a2d6e"><td class="memItemLeft" align="right" valign="top"><a id="ad57048e0479f878af3ac3a27031a2d6e" name="ad57048e0479f878af3ac3a27031a2d6e"></a>
<a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unpause</b> ()</td></tr>
<tr class="memdesc:ad57048e0479f878af3ac3a27031a2d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpause the pool. The workers will resume retrieving new tasks out of the queue. <br /></td></tr>
<tr class="separator:ad57048e0479f878af3ac3a27031a2d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e16153b1a14b5b4d8191168ccf6e4b8" id="r_a1e16153b1a14b5b4d8191168ccf6e4b8"><td class="memItemLeft" align="right" valign="top"><a id="a1e16153b1a14b5b4d8191168ccf6e4b8" name="a1e16153b1a14b5b4d8191168ccf6e4b8"></a>
<a class="el" href="class_b_s_1_1multi__future.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>wait_for_tasks</b> ()</td></tr>
<tr class="memdesc:a1e16153b1a14b5b4d8191168ccf6e4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <a class="el" href="class_b_s_1_1thread__pool.html#ae308645aebac7a10b04aac0eb3a7c29c" title="Submit a function with zero or more arguments into the task queue. If the function has a return value...">submit()</a> instead, and call the wait() member function of the generated future. <br /></td></tr>
<tr class="separator:a1e16153b1a14b5b4d8191168ccf6e4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980dc3c8de9114dc63b0fbfc979b031d" id="r_a980dc3c8de9114dc63b0fbfc979b031d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">P</a> &gt; </td></tr>
<tr class="memitem:a980dc3c8de9114dc63b0fbfc979b031d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a980dc3c8de9114dc63b0fbfc979b031d">wait_for_tasks_duration</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> std::chrono::duration&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a>, <a class="el" href="class_b_s_1_1multi__future.html">P</a> &gt; &amp;<a class="el" href="class_b_s_1_1multi__future.html">duration</a>)</td></tr>
<tr class="memdesc:a980dc3c8de9114dc63b0fbfc979b031d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified duration has passed.  <br /></td></tr>
<tr class="separator:a980dc3c8de9114dc63b0fbfc979b031d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf42daf5d4e6536a32af2279c95b351" id="r_a0bf42daf5d4e6536a32af2279c95b351"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">C</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">D</a> &gt; </td></tr>
<tr class="memitem:a0bf42daf5d4e6536a32af2279c95b351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_b_s_1_1multi__future.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_1_1thread__pool.html#a0bf42daf5d4e6536a32af2279c95b351">wait_for_tasks_until</a> (<a class="el" href="class_b_s_1_1multi__future.html">const</a> std::chrono::time_point&lt; <a class="el" href="class_b_s_1_1multi__future.html">C</a>, <a class="el" href="class_b_s_1_1multi__future.html">D</a> &gt; &amp;<a class="el" href="class_b_s_1_1multi__future.html">timeout_time</a>)</td></tr>
<tr class="memdesc:a0bf42daf5d4e6536a32af2279c95b351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified time point has been reached.  <br /></td></tr>
<tr class="separator:a0bf42daf5d4e6536a32af2279c95b351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A fast, lightweight, and easy-to-use C++17 thread pool class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0705b5edcf3809e4f133272e8070d12" name="af0705b5edcf3809e4f133272e8070d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0705b5edcf3809e4f133272e8070d12">&#9670;&#160;</a></span>thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="_b_s__thread__pool_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab5faf242cb0eacbb5c1142a2bd966468" name="ab5faf242cb0eacbb5c1142a2bd966468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5faf242cb0eacbb5c1142a2bd966468">&#9670;&#160;</a></span>get_tasks_queued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">size_t</a> BS::thread_pool::get_tasks_queued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently waiting in the queue to be executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued tasks. </dd></dl>

</div>
</div>
<a id="a07b4d97e3a9e40e3228e2ed1f9a717cc" name="a07b4d97e3a9e40e3228e2ed1f9a717cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b4d97e3a9e40e3228e2ed1f9a717cc">&#9670;&#160;</a></span>get_tasks_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">size_t</a> BS::thread_pool::get_tasks_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently being executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of running tasks. </dd></dl>

</div>
</div>
<a id="afdec64ff8998d66017cc185ae397e064" name="afdec64ff8998d66017cc185ae397e064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdec64ff8998d66017cc185ae397e064">&#9670;&#160;</a></span>get_tasks_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">size_t</a> BS::thread_pool::get_tasks_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <a class="el" href="class_b_s_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="class_b_s_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="class_b_s_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of tasks. </dd></dl>

</div>
</div>
<a id="afe1cb80839e30f218818e99af4d1dc64" name="afe1cb80839e30f218818e99af4d1dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cb80839e30f218818e99af4d1dc64">&#9670;&#160;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_b_s__thread__pool_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::get_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>

</div>
</div>
<a id="adc7938f7b2b9140c3f6e729b48db79b2" name="adc7938f7b2b9140c3f6e729b48db79b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7938f7b2b9140c3f6e729b48db79b2">&#9670;&#160;</a></span>is_paused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">bool</a> BS::thread_pool::is_paused </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the pool is currently paused. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the pool is paused, false if it is not paused. </dd></dl>

</div>
</div>
<a id="a2f4e0c7b8e0ac08d9cdad40defd36f30" name="a2f4e0c7b8e0ac08d9cdad40defd36f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4e0c7b8e0ac08d9cdad40defd36f30">&#9670;&#160;</a></span>parallelize_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a>  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a> &gt; BS::thread_pool::parallelize_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a>&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. This overload is used for the special case where the first index is 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the loop indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">R</td><td>The return value of the loop function F (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from 0 to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = 0; i &lt; index_after_last; ++i)". Note that if index_after_last == 0, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that can be used to wait for all the blocks to finish. If the loop function returns a value, the <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object can also be used to obtain the values returned by each block. </dd></dl>

</div>
</div>
<a id="ab63b1085ad48295d7f653cbb36a286be" name="ab63b1085ad48295d7f653cbb36a286be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63b1085ad48295d7f653cbb36a286be">&#9670;&#160;</a></span>parallelize_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a>  = std::common_type_t&lt;T1, T2&gt;, <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a>  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">multi_future</a>&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a> &gt; BS::thread_pool::parallelize_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a>&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a>&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">T</td><td>The common type of T1 and T2. </td></tr>
    <tr><td class="paramname">R</td><td>The return value of the loop function F (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; ++i)". Note that if index_after_last == first_index, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that can be used to wait for all the blocks to finish. If the loop function returns a value, the <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object can also be used to obtain the values returned by each block. </dd></dl>

</div>
</div>
<a id="a2ffca1428e1f111220b5f9aed9ff9eac" name="a2ffca1428e1f111220b5f9aed9ff9eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffca1428e1f111220b5f9aed9ff9eac">&#9670;&#160;</a></span>push_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">void</a> BS::thread_pool::push_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a>&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="class_b_s_1_1thread__pool.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. This overload is used for the special case where the first index is 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the loop indices. Should be a signed or unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from 0 to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = 0; i &lt; index_after_last; ++i)". Note that if index_after_last == 0, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7cec549d4a8729beac50f5eba3ec63f" name="ae7cec549d4a8729beac50f5eba3ec63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cec549d4a8729beac50f5eba3ec63f">&#9670;&#160;</a></span>push_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">T</a>  = std::common_type_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">void</a> BS::thread_pool::push_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T1</a>&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">T2</a>&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="class_b_s_1_1multi__future.html">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="class_b_s_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="class_b_s_1_1thread__pool.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">T</td><td>The common type of T1 and T2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; ++i)". Note that if index_after_last == first_index, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016a2a6a7a9c844c94c606aaf517b21c" name="a016a2a6a7a9c844c94c606aaf517b21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016a2a6a7a9c844c94c606aaf517b21c">&#9670;&#160;</a></span>push_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">void</a> BS::thread_pool::push_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">A</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a function with zero or more arguments, but no return value, into the task queue. Does not return a future, so the user must use <a class="el" href="class_b_s_1_1thread__pool.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the task finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. Note that if the task is a class member function, the first argument must be a pointer to the object, i.e. &amp;object (or this), followed by the actual arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d3623b19c51a513fe4612b2157b0314" name="a5d3623b19c51a513fe4612b2157b0314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3623b19c51a513fe4612b2157b0314">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">void</a> BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> <a class="el" href="_b_s__thread__pool_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the number of threads in the pool. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae308645aebac7a10b04aac0eb3a7c29c" name="ae308645aebac7a10b04aac0eb3a7c29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae308645aebac7a10b04aac0eb3a7c29c">&#9670;&#160;</a></span>submit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">F</a> , typename... A, <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a>  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a> &gt; BS::thread_pool::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">A</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with zero or more arguments into the task queue. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an std::future&lt;void&gt; which can be used to wait until the task finishes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the zero or more arguments to pass to the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. Note that if the task is a class member function, the first argument must be a pointer to the object, i.e. &amp;object (or this), followed by the actual arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to be used later to wait for the function to finish executing and/or obtain its returned value if it has one. </dd></dl>

</div>
</div>
<a id="a980dc3c8de9114dc63b0fbfc979b031d" name="a980dc3c8de9114dc63b0fbfc979b031d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980dc3c8de9114dc63b0fbfc979b031d">&#9670;&#160;</a></span>wait_for_tasks_duration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">R</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">P</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">bool</a> BS::thread_pool::wait_for_tasks_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> std::chrono::duration&lt; <a class="el" href="class_b_s_1_1multi__future.html">R</a>, <a class="el" href="class_b_s_1_1multi__future.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified duration has passed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>An arithmetic type representing the number of ticks to wait. </td></tr>
    <tr><td class="paramname">P</td><td>An std::ratio representing the length of each tick in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The time duration to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all tasks finished running, false if the duration expired but some tasks are still running. </dd></dl>

</div>
</div>
<a id="a0bf42daf5d4e6536a32af2279c95b351" name="a0bf42daf5d4e6536a32af2279c95b351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf42daf5d4e6536a32af2279c95b351">&#9670;&#160;</a></span>wait_for_tasks_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">C</a> , <a class="el" href="class_b_s_1_1multi__future.html">typename</a> <a class="el" href="class_b_s_1_1multi__future.html">D</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_1_1multi__future.html">bool</a> BS::thread_pool::wait_for_tasks_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_1_1multi__future.html">const</a> std::chrono::time_point&lt; <a class="el" href="class_b_s_1_1multi__future.html">C</a>, <a class="el" href="class_b_s_1_1multi__future.html">D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified time point has been reached. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the clock used to measure time. </td></tr>
    <tr><td class="paramname">D</td><td>An std::chrono::duration type used to indicate the time point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>The time point at which to stop waiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all tasks finished running, false if the time point was reached but some tasks are still running. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>d:/ken/GitHub/CampbellMuscleLab/models/FiberSim/code/FiberCpp/<a class="el" href="_b_s__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>BS</b></li><li class="navelem"><a class="el" href="class_b_s_1_1thread__pool.html">thread_pool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
